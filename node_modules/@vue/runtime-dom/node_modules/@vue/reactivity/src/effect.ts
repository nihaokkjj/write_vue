import { DirtyLevels } from "./constants"


export function effect(fn, options? ) {
  //创建一个响应式effect, 数据变化后可以重新执行

  //创建一个effect, 只要依赖的属性变化, 就要执行回调
  const _effect = new ReactiveEffect(fn, () => {
    _effect.run()
  })
  _effect.run()

  if(options) {
    Object.assign(_effect, options) //用户传递的覆盖内置的
  }
  const runner = _effect.run.bind(_effect)
  runner._effect = _effect //使外部可以调用
  return runner //外界可以自己调用run
}

export let activeEffect

function preCleanEffect(effect) {
  effect._depsLength = 0
  effect._trackedId++//每次执行, id都是+1
  //如果在同一个effect中, 同一种数据多次调用, id就是相同的
}

function postCleanEffect(effect) {
  //清理多余的长度
  if (effect.deps.length > effect._depsLength) {
    for (let i = effect._depsLength; i < effect.deps.length; ++i) {
     cleanDepEffect(effect.deps[i], effect)
    }
    effect.deps.length = effect._depsLength
  }
}

 export class ReactiveEffect{
  _trackedId = 0 //用于记录当前effect执行了几次
  deps = [] // 数组，用来存储这个 effect 所依赖的所有 dep (Map)
  _depsLenhth = 0
  _running = 0 //判断监听时值是否发生改变
  _dirtyLevel = DirtyLevels.Dirty //脏值

  public active = true //创建的effect是响应式的
  //fn : 用户编写的函数
  //如果fn中依赖的数据发生变化后, 需要重新调用 run()
  constructor(public fn, public scheduler) { }

  public get dirty() {
    return this._dirtyLevel === DirtyLevels.Dirty
  }
  //访问时, 为脏就返回true
  //设置时, 为true就是脏的
  public set dirty(value) {
    this._dirtyLevel = value ? DirtyLevels.Dirty : DirtyLevels.NoDirty
  }

  run() {// 让fn执行
    // 每次运行后, 此值就不脏了, 在这次effect中不在执行
    this._dirtyLevel = DirtyLevels.NoDirty

    if (!this.active) { //不是激活的
      return this.fn()
    }
    let lastEffect = activeEffect
    try {
      activeEffect = this

      //effect重新执行前, 需要将上一次的依赖情况删除
      preCleanEffect(this) //初始化id和length

      this._running++ //值不为0, 需要屏蔽正在运行的effect
      //防止数据在effect中变化造成死循环
      return this.fn()
    } finally {
      this._running--//结束运行
      postCleanEffect(this)
      activeEffect = lastEffect
    }
  }
  stop() { //关闭响应式
    if (this.active) {
      this.active = false
      preCleanEffect(this)
      postCleanEffect(this)
    }
    this.active = false
  }
}

function cleanDepEffect(dep, effect) {
  dep.delete(effect)
  if (dep.size === 0) {
    dep.cleanup() //map为空, 删除
  }
}

//双向记忆
export function trackEffect(effect, dep) {
  // debugger
  //需要重新收集依赖, 将不需要的移除

  //如果这个数之前没有被监测, 或在之前的effect检测过
  //更新id值
  //如果是同一个effect里面重复出现的值, id值相同
  if (dep.get(effect) !== effect._trackedId) {
    dep.set(effect, effect._trackedId)
  } 
  //efect与dep关联
  let oldDep = effect.deps[effect._depsLength]

  if (oldDep !== dep) {//没存过
    //删除老的换新的
    if (oldDep) {
      cleanDepEffect(oldDep, effect)
    }
   effect.deps[effect._depsLength++] = dep
  } else {
    effect._depsLength++
  }
}

export function triggerEffects(dep) {

  for (const effect of dep.keys()) {

    //当前这个值是不脏的, 但是触发更新需要将值变为脏值
    //属性依赖了计算属性, 需要让计算属性的dirty初始化
    if (effect._dirtyLevel < DirtyLevels.Dirty) {
      effect._dirtyLevel = DirtyLevels.Dirty
    }

    if (!effect._running) {
      if(effect.scheduler) {
        effect.scheduler()//不是正在执行, 才能执行
        //否则易造成死循环
      }
    }
  }
}